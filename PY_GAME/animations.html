<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>2D Character Animation</title>
   <script src="https://cdn.tailwindcss.com"></script>
   <style>
       body {
           background-color: #f0f0f0;
           display: flex;
           flex-direction: column;
           align-items: center;
           justify-content: center;
           min-height: 100vh;
           font-family: sans-serif;
       }

       #game-area {
           position: relative;
           width: 500px;
           height: 500px;
           background-color: #a7c957; /* Grassy color */
           border: 2px solid #386641; /* Dark green border */
           border-radius: 8px;
           overflow: hidden;
           box-shadow: 0 10px 20px rgba(0,0,0,0.1);
       }

       .character {
           position: absolute;
           width: 40px;
           height: 40px;
           border-radius: 50%;
           border: 2px solid rgba(0, 0, 0, 0.2);
           box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
           display: flex;
           align-items: center;
           justify-content: center;
           transition: opacity 0.3s ease, transform 0.1s linear;
       }

       /* Non-player characters have eyes */
       .character:not(.player) {
            animation: walk 1s ease-in-out infinite;
       }

       .face {
           display: flex;
           justify-content: space-around;
           align-items: center;
           width: 60%;
       }

       .eye {
           width: 8px;
           height: 8px;
           background-color: white;
           border-radius: 50%;
           border: 1px solid #333;
       }

       /* Player character has a pointer to show direction */
       .player .face {
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 14px solid white;
            transform: translateY(-4px);
       }
      
       /* Apply smooth transitions for player movement and rotation */
       .player {
           transition: left 0.05s linear, top 0.05s linear;
       }
       .player .face-container {
            transition: transform 0.2s ease-out;
       }


       /* Define the colors and initial positions */
       #char-red {
           background-color: #e63946;
           top: 100px;
           left: 100px;
           animation-delay: 0s;
       }

       #char-blue {
           background-color: #457b9d;
           top: 230px;
           left: 230px;
       }

       #char-green {
           background-color: #588157;
           top: 350px;
           left: 120px;
           animation-delay: -0.25s;
       }

       #char-yellow {
           background-color: #ffb703;
           top: 300px;
           left: 400px;
           animation-delay: -0.75s;
       }

       .walking {
           animation: walk 1s ease-in-out infinite;
       }
      
       @keyframes walk {
           0%, 100% {
               transform: scale(1) translateY(0);
           }
           50% {
               transform: scale(1.05) translateY(-5px);
               box-shadow: 0 8px 12px rgba(0, 0, 0, 0.2);
           }
       }

       .instructions-container {
           display: flex;
           gap: 10px;
           margin-top: 20px;
       }

       .instructions, .status-display {
           padding: 10px 20px;
           background-color: white;
           border-radius: 8px;
           box-shadow: 0 2px 4px rgba(0,0,0,0.1);
           color: #333;
           text-align: center;
       }

       .item {
           position: absolute;
           width: 40px;
           height: 40px;
           transition: transform 0.2s ease;
           display: flex;
           align-items: center;
           justify-content: center;
       }
       .item:hover {
           transform: scale(1.2);
       }

       /* Weapon Styles */
       .weapon-holder {
           position: absolute;
           width: 100%;
           height: 100%;
           transition: transform 0.2s ease-out;
       }

       .weapon {
           position: absolute;
           top: -30px; /* Position weapon in front of player */
           left: 15px;
           display: none;
           transform-origin: center 35px; /* Set origin for swing animation */
       }

       /* Make sure weapons on the ground are visible */
       .item .weapon {
           display: block;
           position: static; /* Override absolute positioning within the item container */
           top: auto;
           left: auto;
       }
      
       .player.equipped .weapon {
           display: block;
       }
      
       .weapon-holder.attacking .weapon {
           animation: swing 0.3s ease-out;
       }
      
       /* Sword Style - More Opaque */
       .sword .handle { background-color: #61482d; }
       .sword .blade { background-color: #d1d1d1; border: 1px solid #9a9a9a; }
       .sword .handle { width: 6px; height: 10px; top: 28px; left: 17px; position: absolute; }
       .sword .blade { width: 4px; height: 28px; top: 0px; left: 18px; position: absolute; border-radius: 2px;}
      
       /* Axe Style - More Opaque */
       .axe .handle { position: absolute; width: 6px; height: 35px; background: #61482d; top: 2px; left: 17px;}
       .axe .blade { position: absolute; width: 20px; height: 18px; background: #acb4be; border: 1px solid #7f8a95; top: 0px; left: 10px; border-radius: 4px 10px 10px 4px;}

       /* Hammer Style - More Opaque */
       .hammer .handle { position: absolute; width: 6px; height: 30px; background: #61482d; top: 10px; left: 17px; }
       .hammer .head { position: absolute; width: 24px; height: 16px; background: #97a1af; border: 1px solid #636e7b; top: 0; left: 8px; border-radius: 3px;}


       .hit {
           animation: hit-flash 0.3s ease;
       }
      
       .dying {
           animation: die 0.5s ease-out forwards;
       }

       .splatter {
           position: absolute;
           width: 50px;
           height: 50px;
           background-color: #e63946;
           border-radius: 50%;
           opacity: 0.7;
           transform: translate(-50%, -50%) scale(0); /* Start small and centered */
           animation: splatter-fade 0.5s ease-out forwards;
           pointer-events: none; /* Make sure it doesn't interfere with clicks */
       }

       @keyframes hit-flash {
           0% { background-color: #e63946; }
           50% { background-color: white; transform: scale(1.1); }
           100% { background-color: #e63946; }
       }

       @keyframes swing {
           0% { transform: rotate(-60deg); }
           50% { transform: rotate(60deg); }
           100% { transform: rotate(0deg); }
       }

       @keyframes die {
           0% {
               transform: scale(1);
               opacity: 1;
               filter: brightness(1);
           }
           70% {
               transform: scale(1.8); /* Swell up */
               opacity: 1;
               filter: brightness(3); /* Flash brightly */
           }
           100% {
               transform: scale(0); /* Pop */
               opacity: 0;
               filter: brightness(1);
           }
       }

       @keyframes splatter-fade {
           0% {
               transform: translate(-50%, -50%) scale(0);
               opacity: 0.7;
           }
           80% {
               transform: translate(-50%, -50%) scale(1);
               opacity: 0.5;
           }
           100% {
               transform: translate(-50%, -50%) scale(1.2);
               opacity: 0;
           }
       }
   </style>
</head>
<body>

   <div id="game-area">
       <!-- Items -->
       <div id="item-container"></div>
    
       <!-- Characters -->
       <div id="char-red" class="character enemy">
            <div class="face">
               <div class="eye"></div>
               <div class="eye"></div>
           </div>
       </div>
       <div id="char-green" class="character enemy">
            <div class="face">
               <div class="eye"></div>
               <div class="eye"></div>
           </div>
       </div>
       <div id="char-yellow" class="character enemy">
            <div class="face">
               <div class="eye"></div>
               <div class="eye"></div>
           </div>
       </div>
       <!-- Player Character -->
       <div id="char-blue" class="character player">
           <div class="face-container">
               <div class="face"></div>
           </div>
           <div class="weapon-holder"></div>
       </div>
   </div>

   <div class="instructions-container">
       <div class="instructions">
           <strong>WASD:</strong> Move | <strong>L:</strong> Attack
       </div>
       <div class="status-display">
           Equipped: <strong id="weapon-status" class="text-gray-500">None</strong><span id="weapon-hits" class="font-normal text-gray-500 ml-1"></span>
       </div>
   </div>

   <script>
       document.addEventListener('DOMContentLoaded', () => {
           const player = document.getElementById('char-blue');
           const gameArea = document.getElementById('game-area');
           const itemContainer = document.getElementById('item-container');
           const weaponStatusEl = document.getElementById('weapon-status');
           const enemies = Array.from(document.querySelectorAll('.enemy'));
           const weaponHolder = player.querySelector('.weapon-holder');

           const playerState = {
               speed: 5,
               posX: player.offsetLeft,
               posY: player.offsetTop,
               rotation: 0,
               equippedWeapon: null,
               canAttack: true,
               weaponHitsLeft: 0,
           };

           const keysPressed = { w: false, a: false, s: false, d: false };
           let items = [];

           function findSpawnPosition() {
               const gameAreaRect = gameArea.getBoundingClientRect();
               const padding = 40;
               const safeZoneRadius = 80;
               const itemSpacing = 50;
              
               // Use the player's current position if the game is running, otherwise use start
               const playerCurrentX = playerState ? playerState.posX : player.offsetLeft;
               const playerCurrentY = playerState ? playerState.posY : player.offsetTop;

               const spawnedPositions = items.filter(i => i.element).map(i => ({ x: i.x, y: i.y }));
              
               let newX, newY, tooClose;
               let attempts = 0; // Prevent infinite loops
               do {
                   tooClose = false;
                   attempts++;
                   if (attempts > 50) { // Failsafe
                       console.error("Could not find a valid spawn position.");
                       return null;
                   }
                   newX = Math.floor(Math.random() * (gameAreaRect.width - padding * 2)) + padding;
                   newY = Math.floor(Math.random() * (gameAreaRect.height - padding * 2)) + padding;

                   // Check distance from player's current position
                   const dxPlayer = newX - playerCurrentX;
                   const dyPlayer = newY - playerCurrentY;
                   if (Math.sqrt(dxPlayer * dxPlayer + dyPlayer * dyPlayer) < safeZoneRadius) {
                       tooClose = true;
                       continue;
                   }

                   // Check distance from other items
                   for(const pos of spawnedPositions) {
                       const dxItem = newX - pos.x;
                       const dyItem = newY - pos.y;
                       if (Math.sqrt(dxItem * dxItem + dyItem * dyItem) < itemSpacing) {
                           tooClose = true;
                           break;
                       }
                   }
               } while (tooClose);

               return { x: newX, y: newY };
           }

           function spawnSingleWeapon(type) {
               const itemEl = document.createElement('div');
               itemEl.className = `item`;
              
               const pos = findSpawnPosition();
               if (!pos) return;

               const newItem = { type: type, element: itemEl, x: pos.x, y: pos.y };

               itemEl.style.left = `${newItem.x}px`;
               itemEl.style.top = `${newItem.y}px`;
               itemEl.innerHTML = weaponContainerHTML(type);

               itemContainer.appendChild(itemEl);
               items.push(newItem);
           }

           function trySpawnWeapon() {
               const MAX_ITEMS = 6;
               const currentItemCount = items.filter(i => i.element).length;

               if (currentItemCount >= MAX_ITEMS) {
                   return;
               }
               const weaponTypes = ['sword', 'axe', 'hammer'];
               const type = weaponTypes[Math.floor(Math.random() * weaponTypes.length)];
               spawnSingleWeapon(type);
           }


           function spawnItems() {
               itemContainer.innerHTML = '';
               items = [];
               ['sword', 'axe', 'hammer'].forEach(type => spawnSingleWeapon(type));
           }

           function isColliding(rect1, rect2) {
               return !(rect1.right < rect2.left ||
                        rect1.left > rect2.right ||
                        rect1.bottom < rect2.top ||
                        rect1.top > rect2.bottom);
           }

           document.addEventListener('keydown', (event) => {
               const key = event.key.toLowerCase();
               if (keysPressed.hasOwnProperty(key)) {
                   keysPressed[key] = true;
                   player.classList.add('walking');
               }
               if (key === 'l' && playerState.equippedWeapon && playerState.canAttack) {
                   attack();
               }
           });

           document.addEventListener('keyup', (event) => {
               const key = event.key.toLowerCase();
               if (keysPressed.hasOwnProperty(key)) {
                   keysPressed[key] = false;
               }
               if (Object.values(keysPressed).every(val => !val)) {
                   player.classList.remove('walking');
               }
           });

           function attack() {
               playerState.canAttack = false;
              
               weaponHolder.classList.add('attacking');

               // Check for hits
               const attackRange = 70; // pixels
               const attackAngle = 90; // degrees (45 each side)

               enemies.forEach(enemy => {
                   if (enemy.style.display !== 'none' && !enemy.classList.contains('dying')) {
                       const dx = (enemy.offsetLeft + enemy.offsetWidth/2) - (playerState.posX + player.offsetWidth/2);
                       const dy = (enemy.offsetTop + enemy.offsetHeight/2) - (playerState.posY + player.offsetHeight/2);
                       const distance = Math.sqrt(dx*dx + dy*dy);
                      
                       if (distance < attackRange) {
                           const angleToEnemy = Math.atan2(dx, -dy) * (180 / Math.PI);
                           let angleDiff = Math.abs(playerState.rotation - angleToEnemy);
                           if (angleDiff > 180) angleDiff = 360 - angleDiff;

                           if (angleDiff <= attackAngle / 2) {
                               if (playerState.equippedWeapon) {
                                   playerState.weaponHitsLeft--;
                                   updateWeaponStatus(false); // Update hits display without resetting

                                   if (playerState.weaponHitsLeft <= 0) {
                                       playerState.equippedWeapon = null;
                                       setTimeout(() => {
                                            updateWeaponStatus(true);
                                       }, 100);
                                   }
                               }
                              
                               // Create blood splatter
                               const splatter = document.createElement('div');
                               splatter.className = 'splatter';
                               splatter.style.left = `${enemy.offsetLeft + enemy.offsetWidth / 2}px`;
                               splatter.style.top = `${enemy.offsetTop + enemy.offsetHeight / 2}px`;
                               gameArea.appendChild(splatter);

                               // Remove splatter after animation
                               setTimeout(() => {
                                   splatter.remove();
                               }, 500);

                               enemy.classList.add('hit');
                               // Mark as dying so it can't be hit again
                               enemy.classList.add('dying');

                               // Remove the hit flash after it plays
                               setTimeout(() => {
                                   enemy.classList.remove('hit');
                               }, 300);

                               // After the dying animation finishes, hide the element
                               setTimeout(() => {
                                  enemy.style.display = 'none';
                               }, 500); // Matches the 'die' animation duration
                           }
                       }
                   }
               });

               setTimeout(() => {
                   playerState.canAttack = true;
                   weaponHolder.classList.remove('attacking');
               }, 300); // Animation duration
           }

           function updateWeaponStatus(resetHits = true) {
               const weaponHitsEl = document.getElementById('weapon-hits');
               if (playerState.equippedWeapon) {
                   if (resetHits) {
                       playerState.weaponHitsLeft = 3;
                   }
                   weaponStatusEl.textContent = playerState.equippedWeapon.charAt(0).toUpperCase() + playerState.equippedWeapon.slice(1);
                   weaponHitsEl.textContent = `(${playerState.weaponHitsLeft}/3)`;
                   weaponStatusEl.className = 'text-blue-600';
                   player.classList.add('equipped');
                   weaponHolder.innerHTML = weaponContainerHTML(playerState.equippedWeapon);
               } else {
                   weaponStatusEl.textContent = 'None';
                   weaponHitsEl.textContent = '';
                   weaponStatusEl.className = 'text-gray-500';
                   player.classList.remove('equipped');
                   weaponHolder.innerHTML = '';
                   playerState.weaponHitsLeft = 0;
               }
           }
          
           function weaponContainerHTML(type) {
               if (type === 'sword') return `<div class="weapon sword"><div class="blade"></div><div class="handle"></div></div>`;
               if (type === 'axe') return `<div class="weapon axe"><div class="handle"></div><div class="blade"></div></div>`;
               if (type === 'hammer') return `<div class="weapon hammer"><div class="handle"></div><div class="head"></div></div>`;
               return '';
           }

           function gameLoop() {
               let dx = 0;
               let dy = 0;

               if (keysPressed.w) dy -= 1;
               if (keysPressed.s) dy += 1;
               if (keysPressed.a) dx -= 1;
               if (keysPressed.d) dx += 1;

               if (dx !== 0 || dy !== 0) {
                   let angle = Math.atan2(dx, -dy) * (180 / Math.PI);
                   playerState.rotation = angle;
                   player.querySelector('.face-container').style.transform = `rotate(${angle}deg)`;
                   weaponHolder.style.transform = `rotate(${angle}deg)`;

                   playerState.posX += dx * playerState.speed;
                   playerState.posY += dy * playerState.speed;

                   const charSize = player.offsetWidth;
                   const areaWidth = gameArea.offsetWidth;
                   const areaHeight = gameArea.offsetHeight;

                   playerState.posX = Math.max(0, Math.min(areaWidth - charSize, playerState.posX));
                   playerState.posY = Math.max(0, Math.min(areaHeight - charSize, playerState.posY));

                   player.style.left = `${playerState.posX}px`;
                   player.style.top = `${playerState.posY}px`;
               }
              
               // Collision checks: Player vs Item
               const playerRect = player.getBoundingClientRect();
               items.forEach((item) => {
                   if (item.element) {
                       const itemRect = item.element.getBoundingClientRect();
                       if (isColliding(playerRect, itemRect)) {
                           playerState.equippedWeapon = item.type;
                           item.element.remove();
                           item.element = null;
                           updateWeaponStatus(true);
                           trySpawnWeapon();
                       }
                   }
               });
              
               requestAnimationFrame(gameLoop);
           }

           spawnItems();
           updateWeaponStatus();
           gameLoop();
       });
   </script>
</body>
</html>



